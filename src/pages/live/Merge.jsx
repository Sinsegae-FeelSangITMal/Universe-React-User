// Merge.jsx
import { useState, useRef, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { io } from 'socket.io-client';
import * as mediasoupClient from 'mediasoup-client';
import SockJS from 'sockjs-client';
import { Client as StompClient } from '@stomp/stompjs';
import toast from 'react-hot-toast';
import { useAuthStore } from '../../store/auth';

import { getStream } from "../../utils/StreamApi";
import { getStreamProductsByStream } from "../../utils/StreamProductApi";
import { getPromotion } from "../../utils/PromotionApi";
import SubtitleDisplay from '../../components/subtitle/SubtitleDisplay';

// ---- Endpoints (vite proxy Í∏∞Ï§Ä) ----
const SERVER_URL = '/'; // Connect to the same host, will be routed by Gateway
const CHAT_API_BASE_URL = '/chatapi'; // Routed by Gateway
const MAIN_API_URL = '/api'; // Routed by Gateway
const CHAT_WS_URL = '/ws'; // Routed by Gateway

// ---- STOMP Topics ----
const TOPIC_SUBSCRIBE = (id) => `/topic/public/${id ?? 'global'}`;
const APP_SEND = (id) => `/app/live/${id ?? 'global'}`;

export default function Merge() {
  const { artistId, liveId } = useParams();
  const navigate = useNavigate();
  const { user, accessToken } = useAuthStore();

  // ===== Refs =====
  const remoteVideoRef = useRef(null);
  const chatMessagesRef = useRef(null);
  const composingRef = useRef(false);
  const stompRef = useRef(null);

  const socketRef = useRef(null);
  const deviceRef = useRef(null);
  const recvTransportRef = useRef(null);
  const subtitleTimerRef = useRef(null);
  const initOnceRef = useRef(false); // StrictMode Ï§ëÎ≥µ Ïã§Ìñâ Í∞ÄÎìú

  // ÌòÑÏû¨ video.srcObjectÏóê Ìï†Îãπ/Í¥ÄÎ¶¨Ìï† MediaStream
  const msRef = useRef(null);

  // ===== States =====
  const [chatList, setChatList] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [isMuted, setIsMuted] = useState(false);
  const [muteSecondsLeft, setMuteSecondsLeft] = useState(0);
  const [isBanned, setIsBanned] = useState(false);

  const [streamStatus, setStreamStatus] = useState('waiting'); // waiting | streaming | ended | vod
  const [isStreamAvailable, setIsStreamAvailable] = useState(false);
  const [subtitle, setSubtitle] = useState(null);
  const [selectedLang, setSelectedLang] = useState('ko');
  const [viewerCount, setViewerCount] = useState(0);

  const [streamInfo, setStreamInfo] = useState(null);
  const [promotion, setPromotion] = useState(null);
  const [productDetails, setProductDetails] = useState([]);

  const myUserId = user?.userId || 0;

  // üîπ VOD Ï†ÑÌôò Ìó¨Ìçº
  const setVideoToVod = (recordPath) => {
    const videoEl = remoteVideoRef.current;
    if (!videoEl) return;

    // Ïã§ÏãúÍ∞Ñ Ìä∏Îûô Ï†ïÎ¶¨
    if (videoEl.srcObject) {
      try { videoEl.srcObject.getTracks?.().forEach((t) => t.stop?.()); } catch { }
      videoEl.srcObject = null;
    }

    // Ï†àÎåÄ/ÏÉÅÎåÄ Í≤ΩÎ°ú ÎåÄÏùë
    const base = import.meta.env.VITE_API_URL || '';
    const src = recordPath?.startsWith('http')
      ? recordPath
      : `${base}${recordPath || ''}`;

    videoEl.crossOrigin = 'anonymous';
    videoEl.src = src;
    videoEl.controls = true;
    videoEl.muted = false;
    videoEl.playsInline = true;
    try { videoEl.load(); } catch { }

    setIsStreamAvailable(true);
    setStreamStatus('vod');
  };

  // Merge.jsx ÏÉÅÎã® helpers Í∑ºÏ≤òÏóê Ïù¥ÎØ∏ msRefÍ∞Ä ÏûàÏúºÎãà, ÏïÑÎûò effectÎ•º Ï∂îÍ∞Ä:
  useEffect(() => {
    const v = remoteVideoRef.current;
    if (!v) return;
    if (!(msRef.current instanceof MediaStream)) {
      msRef.current = new MediaStream();
    }
    if (v.srcObject !== msRef.current) {
      v.srcObject = msRef.current;
    }
    v.muted = true;         // autoplay ÌóàÏö©
    v.playsInline = true;
    // Ï¥àÍ∏∞ play ÌÇ•(ÌîÑÎ†àÏûÑ Îì§Ïñ¥Ïò§Î©¥ ÏûêÏó∞Ïä§ÎüΩÍ≤å ÌùêÎ¶Ñ Ïù¥Ïñ¥Ïßê)
    const p = v.play?.();
    if (p && p.catch) p.catch(() => { });
  }, []); // ‚Üê ÏµúÏ¥à 1Ìöå


  // =========================
  // Video helpers (Í∞ÄÏû• Ï§ëÏöî) ‚Äî Ïù¥ Î∏îÎ°ùÎßå ÍµêÏ≤¥
  // =========================

  // ‚úÖ srcObjectÎ•º Î∂àÌïÑÏöîÌïòÍ≤å ÎÅäÏßÄ ÏïäÎèÑÎ°ù ‚ÄúÏ°∞Í±¥Î∂Ä‚Äù Ìï†ÎãπÎßå
  function ensureAssigned(video, ms) {
    if (!video) return;
    if (video.srcObject !== ms) {
      video.srcObject = ms;
    }
  }

  function tryPlay(video) {
    if (!video) return;
    // ÏûêÎèôÏû¨ÏÉù ÏπúÌôî
    video.muted = true;
    video.playsInline = true;
    const p = video.play?.();
    if (p && p.catch) p.catch(() => { });
  }

  // kind Ïä§ÏúÑÏπò
  function attachTrack(track, kind) {
    if (kind === 'video') attachVideoTrack(track);
    else if (kind === 'audio') attachAudioTrack(track);
    else console.warn('[attachTrack] unknown kind:', kind);
  }

  // ‚úÖ ÎπÑÎîîÏò§ Ìä∏Îûô
  function attachVideoTrack(track) {
    const video = remoteVideoRef.current;
    if (!video) return;

    // 1) Îπà Ïä§Ìä∏Î¶ºÏù¥ Ïù¥ÎØ∏ videoÏóê ÍΩÇÌòÄÏûàÏùå (1Î≤à Î≥ÄÍ≤ΩÏóêÏÑú Ï≤òÎ¶¨)
    const ms = (msRef.current instanceof MediaStream) ? msRef.current : new MediaStream();

    // 2) Í∏∞Ï°¥ ÎπÑÎîîÏò§ Ìä∏ÎûôÎßå ÍµêÏ≤¥ (stopÏùÄ ÏÑ†ÌÉù, "removeTrack"Îßå ÌïòÍ≥† stopÏùÄ ÏÉùÎûµ Ï∂îÏ≤ú)
    ms.getVideoTracks().forEach(t => { try { ms.removeTrack(t); } catch { } });

    // 3) ÏÉà ÎπÑÎîîÏò§ Ìä∏Îûô Ï∂îÍ∞Ä
    track.enabled = true; // ÌòπÏãú Î™®Î•º disable Î∞©ÏßÄ
    ms.addTrack(track);
    msRef.current = ms;

    // ‚ùóÏó¨Í∏∞ÏÑú srcObject Ïû¨Ìï†Îãπ/ÎπÑÏö∞Í∏∞/ load() Ï†àÎåÄ Í∏àÏßÄ (Ïù¥ÎØ∏ 1Ìöå ÍΩÇÏïÑÎëî ÏÉÅÌÉú)
    // ensureAssigned(video, ms)ÎèÑ Ìò∏Ï∂úÌï† ÌïÑÏöî ÏóÜÏùå

    // 4) play ÌÇ•
    const kick = () => {
      const p = video.play?.();
      if (p && p.catch) p.catch(() => { });
    };

    if (track.muted) {
      try { track.addEventListener('unmute', kick, { once: true }); } catch { }
    } else {
      kick();
    }

    // Î≥¥Í∞ï
    video.addEventListener('loadeddata', kick, { once: true });
    video.addEventListener('canplay', kick, { once: true });
    if ('requestVideoFrameCallback' in video) {
      // @ts-ignore
      video.requestVideoFrameCallback(() => kick());
    }

    // ÎîîÎ≤ÑÍ∑∏
    const s = video.srcObject;
    console.log('[VideoState]', {
      videoTracks: s ? s.getVideoTracks().map(t => ({ id: t.id, muted: t.muted, readyState: t.readyState })) : [],
      audioTracks: s ? s.getAudioTracks().map(t => ({ id: t.id, muted: t.muted, readyState: t.readyState })) : [],
      paused: video.paused,
      readyState: video.readyState
    });
  }

  // ‚úÖ Ïò§ÎîîÏò§ Ìä∏Îûô
  function attachAudioTrack(track) {
    const video = remoteVideoRef.current;
    if (!video) return;

    const ms = (msRef.current instanceof MediaStream) ? msRef.current : new MediaStream();

    if (!ms.getAudioTracks().some(t => t.id === track.id)) {
      track.enabled = true;
      ms.addTrack(track);
    }
    msRef.current = ms;

    // ‚ùóÏó¨Í∏∞ÎèÑ srcObject Ïû¨Ìï†Îãπ Ï†àÎåÄ Í∏àÏßÄ (Ïù¥ÎØ∏ 1Ìöå ÍΩÇÌûò)
    // ÌïÑÏöîÏãú ÌîåÎ†àÏù¥ ÌÇ•Îßå
    const p = video.play?.();
    if (p && p.catch) p.catch(() => { });
  }
  // =========================

  // ===== Ï±ÑÌåÖ ÏûêÎèô Ïä§ÌÅ¨Î°§ =====
  useEffect(() => {
    if (chatMessagesRef.current) {
      chatMessagesRef.current.scrollTop = chatMessagesRef.current.scrollHeight;
    }
  }, [chatList]);

  // ===== Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ =====
  useEffect(() => {
    const fetchData = async () => {
      try {
        const streamResp = await getStream(liveId);
        const s = streamResp?.data?.data || streamResp?.data || {};
        setStreamInfo({ title: s?.title, artistName: s?.artistName });

        // üîπ Ïä§Ìä∏Î¶º ÏÉÅÌÉú/ÎÖπÌôîÏóê Îî∞Îùº VOD Î™®Îìú Ï†ÑÌôò
        const status = (s?.srStatus || s?.status || '').toString().toUpperCase();
        const record = s?.record || s?.srRecord;
        if (record && (status === 'ENDED' || status === 'END' || status === 'COMPLETED')) {
          setVideoToVod(record);
        } else {
          // ÎÖπÌôîÍ∞Ä ÏóÜÍ±∞ÎÇò ÎùºÏù¥Î∏å Ï§ëÏù¥Î©¥ ÎåÄÍ∏∞/ÎùºÏù¥Î∏å ÏÉÅÌÉúÎäî mediasoup effectÏóêÏÑú Ï≤òÎ¶¨
          if (status === 'LIVE') {
            setStreamStatus('waiting');
          } else if (status === 'WAITING') {
            setStreamStatus('waiting');
          } else if (status === 'ENDED') {
            setStreamStatus('ended');
          }
        }

        const promoId = s?.promotionId ?? s?.promotion_id ?? s?.PR_ID;
        if (promoId) {
          const pr = await getPromotion(promoId);
          const d = pr?.data?.data || pr?.data || {};
          setPromotion({ ...d });
        }

        const spResp = await getStreamProductsByStream(liveId);
        const spList = Array.isArray(spResp?.data?.data) ? spResp.data.data : [];
        const products = spList.map((sp) => ({ ...(sp.product || {}) }));
        setProductDetails(products);
      } catch (err) {
        console.error('[Live] Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', err);
      }
    };
    if (liveId) fetchData();
  }, [liveId]);

  // ===== STOMP/SockJS Ï±ÑÌåÖ =====
  useEffect(() => {
    if (!accessToken) return;

    console.log(`[Chat] SockJS Ïó∞Í≤∞ ÏãúÎèÑ: ${CHAT_WS_URL}`);
    const client = new StompClient({
      webSocketFactory: () => new SockJS(CHAT_WS_URL),
      connectHeaders: { Authorization: `Bearer ${accessToken}` }, // CONNECT ÌîÑÎ†àÏûÑÏóêÏÑú Í≤ÄÏ¶ù
      reconnectDelay: 4000,
      onConnect: (frame) => {
        // 1. Í≥µÏö© Ï±ÑÌåÖ Íµ¨ÎèÖ
        client.subscribe(TOPIC_SUBSCRIBE(artistId), (f) => {
          try {
            const body = JSON.parse(f.body);
            // ÏÑúÎ≤Ñ: { roomId, senderId, nickname, content, contentType, createdAt }
            setChatList((prev) => [
              ...prev,
              {
                id: `${body.createdAt ?? Date.now()}-${Math.random()}`,
                senderId: body.senderId ?? 0,
                nickname: body.nickname ?? 'ÏùµÎ™Ö',
                text: body.content ?? '',
                type: body.contentType === 'SYSTEM' ? 'admin' : 'user',
                createdAt: body.createdAt,
              },
            ]);
          } catch {
            setChatList((prev) => [
              ...prev,
              { id: `${Date.now()}-${Math.random()}`, senderId: -1, nickname: 'ÏãúÏä§ÌÖú', text: f.body, type: 'admin' },
            ]);
          }
        });

        // 2. Í∞úÏù∏ ÏãúÏä§ÌÖú Î©îÏãúÏßÄ Íµ¨ÎèÖ (Mute/Ban ÏïåÎ¶ºÏö©)
        client.subscribe(`/queue/system-${myUserId}`, (message) => {
          try {
            const payload = JSON.parse(message.body);

            if (payload.code === 'BANNED') {
              setIsBanned(true);
            } else if (payload.code === 'MUTED') {
              toast(payload.message, { icon: 'ü§´' });
              setIsMuted(true);
              setMuteSecondsLeft(30);
            }

          } catch (e) {
            // JSON ÌååÏã± Ïã§Ìå® Ïãú ÏùºÎ∞ò ÌÖçÏä§Ìä∏Î°ú Ï≤òÎ¶¨
            toast.error(message.body);
          }
        });
      },
      onStompError: (frame) =>
        console.error('[Chat] Broker error:', frame.headers['message'], frame.body),
      onWebSocketError: (evt) => console.error('[Chat] WebSocket error:', evt),
      onWebSocketClose: (evt) => console.warn('[Chat] WebSocket closed:', evt?.code, evt?.reason),
    });

    client.activate();
    stompRef.current = client;
    return () => {
      try { client.deactivate(); } catch { }
      stompRef.current = null;
    };
  }, [artistId, accessToken, navigate]);

  // üß† 1Ô∏è‚É£ ÏûêÎßâ STOMP Íµ¨ÎèÖ (Spring Boot)
  useEffect(() => {
    if (!liveId) return;

    const SUBTITLE_API_URL = import.meta.env.VITE_LIVE_URL; // Viewer.jsx Î∞©Ïãù
    const sockUrl = `${SUBTITLE_API_URL}/ws-subtitle`;

    console.log(`[Subtitle] Connecting STOMP for liveId=${liveId}`);
    console.log("[Subtitle] SockJS connecting to:", sockUrl);

    const sock = new SockJS(sockUrl);
    const subtitleClient = new StompClient({
      webSocketFactory: () => sock,
      reconnectDelay: 4000,
      debug: (str) => console.log("[Subtitle DEBUG]", str),
      onConnect: () => {
        console.log('[Subtitle] STOMP connected');
        subtitleClient.subscribe(`/topic/subtitles/${liveId}`, (frame) => {
          try {
            const payload = JSON.parse(frame.body);
            console.log('[Subtitle] Received:', payload);
            setSubtitle(payload);
            if (subtitleTimerRef.current) clearTimeout(subtitleTimerRef.current);
            subtitleTimerRef.current = setTimeout(() => setSubtitle(null), 6000);
          } catch (err) {
            console.error('ÏûêÎßâ ÌååÏã± Ïã§Ìå®', err);
          }
        });
      },
      onStompError: (frame) => {
        console.error('[Subtitle] Broker error:', frame.headers['message'], frame.body);
      },
      onWebSocketError: (evt) => {
        console.error('[Subtitle] WebSocket error:', evt);
      },
      onWebSocketClose: (evt) => {
        console.warn('[Subtitle] WebSocket closed:', evt?.code, evt?.reason);
      },
    });

    subtitleClient.activate();

    return () => {
      try { subtitleClient.deactivate(); } catch { }
    };
  }, [liveId]);



  // üé• 2Ô∏è‚É£ Mediasoup (socket.io)
  useEffect(() => {
    if (!liveId) {
      console.warn('[Live] liveIdÍ∞Ä ÏóÜÏñ¥ ÏÜåÏºì Ïó∞Í≤∞ÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.');
      return;
    }
    // üîπ VOD Î™®ÎìúÏùº Í≤ΩÏö∞ Ïã§ÏãúÍ∞Ñ ÏÜåÎπÑÎ•º Í±¥ÎÑàÎúÄ
    if (streamStatus === 'vod') {
      console.log('üìÅ VOD Î™®Îìú: mediasoup Ïó∞Í≤∞/consume Ïä§ÌÇµ');
      return;
    }
    if (initOnceRef.current) return;
    initOnceRef.current = true;

    console.log('[Live] EFFECT ENTER', { liveId });

    const socket = io(SERVER_URL, {
      path: SOCKET_PATH,
      transports: ['websocket'],
      query: { role: 'viewer', liveId: String(liveId) },
      forceNew: true,
    });

    socketRef.current = socket;
    window.__viewerSocket = socket;

    socket.on('connect', () => {
      console.log(`üîó Ïó∞Í≤∞Îê®: ${socket.id}, role=viewer, liveId=${liveId}`);
      socket.emit('join-live', { liveId: String(liveId) });
    });

    socket.on('disconnect', (reason) =>
      console.warn(`‚ùå Ïó∞Í≤∞ ÎÅäÍπÄ: ${socket.id}, reason=${reason}`)
    );
    socket.on('connect_error', (e) => console.error('[Live] connect_error:', e?.message || e));

    socket.on('viewer-count', (count) => {
      setViewerCount(count);
    });

    // ÏûêÎßâ
    const handleSubtitleEvent = (data) => {
      try {
        let payload = data;
        if (typeof data === 'string') payload = { original: data };
        if (payload.liveId && String(payload.liveId) !== String(liveId)) return;
        const incoming = payload.subtitle || payload;
        const normalized = typeof incoming === 'string' ? { original: incoming } : incoming;
        if (normalized?.original) {
          setSubtitle(normalized);
          if (subtitleTimerRef.current) clearTimeout(subtitleTimerRef.current);
          subtitleTimerRef.current = setTimeout(() => setSubtitle(null), 6000);
        }
      } catch (err) {
        console.error('ÏûêÎßâ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò', err);
      }
    };
    socket.on('subtitle', handleSubtitleEvent);
    socket.on('subtitle-update', handleSubtitleEvent);

    // ===== Mediasoup setup =====
    const setupMediasoup = async () => {
      try {
        // ÎùºÏö∞ÌÑ∞ Capabilities
        const routerRtpCapabilities = await new Promise((r) =>
          socket.emit('getRouterRtpCapabilities', r)
        );
        console.log('[MS] routerRtpCapabilities:', routerRtpCapabilities);

        const device = new mediasoupClient.Device();
        await device.load({ routerRtpCapabilities });
        deviceRef.current = device;

        // Recv Transport ÏÉùÏÑ±
        const transportParams = await new Promise((r) =>
          socket.emit('createWebRtcTransport', { sending: false }, r)
        );
        console.log('[MS] recv transport params:', transportParams);

        const transport = device.createRecvTransport(transportParams);
        recvTransportRef.current = transport;

        // DTLS connect (ÏÑúÎ≤ÑÎäî { dtlsParameters }Îßå Î∞õÏùå)
        transport.on('connect', ({ dtlsParameters }, callback, errback) => {
          socket.emit('connectTransport', { dtlsParameters }, (error) => {
            if (error) errback(new Error(error));
            else callback();
          });
        });

        // ÎπÑÎîîÏò§/Ïò§ÎîîÏò§ Í∞ÅÍ∞Å ÏÜåÎπÑ
        const consumeKind = async (kind) => {
          const { rtpCapabilities } = deviceRef.current;
          const params = await new Promise((r) =>
            socket.emit(
              'consume',
              { rtpCapabilities, kind, liveId },
              r
            )
          );

          if (!params || params?.error) {
            console.warn(`[MS] consume(${kind}) ÎåÄÍ∏∞/Ïã§Ìå®:`, params?.error || params);
            return false;
          }

          const consumer = await recvTransportRef.current.consume(params);
          const track = consumer.track;

          const attachNow = async () => {
            // 1) Ìä∏Îûô Î∂ôÏù¥Í∏∞ (ÎπÑÎîîÏò§ Î®ºÏ†Ä, Ïò§ÎîîÏò§Îäî add)
            attachTrack(track, kind);

            // 2) ÏÜåÎπÑ Ïû¨Í∞ú
            try { await consumer.resume(); } catch (e) { console.warn('[consume] resume error:', e); }

            // 3) (Í∞ÄÎä•ÌïòÎ©¥) Ï≤´ ÌÇ§ÌîÑÎ†àÏûÑ ÏöîÏ≤≠ - ÎπÑÎîîÏò§ ÌíàÏßà/Ï¥àÍ∏∞ÌîÑÎ†àÏûÑ ÏïûÎãπÍπÄ
            if (consumer.requestKeyFrame) {
              try { await consumer.requestKeyFrame(); } catch { }
            }

            // 4) ÏÑúÎ≤Ñ ack (ÏÑúÎ≤ÑÏóêÏÑú Î≠îÍ∞Ä Ìï† Í≤å ÏóÜÏúºÎ©¥ Î¨¥Ìï¥)
            socket.emit('resume-consumer', { consumerId: consumer.id });

            // ÎîîÎ≤ÑÍπÖ
            const v = remoteVideoRef.current;
            const ms = v?.srcObject;
            console.log('[VideoState]', {
              videoTracks: ms ? ms.getVideoTracks().map(t => ({ id: t.id, muted: t.muted, readyState: t.readyState })) : [],
              audioTracks: ms ? ms.getAudioTracks().map(t => ({ id: t.id, muted: t.muted, readyState: t.readyState })) : [],
              paused: v?.paused,
              readyState: v?.readyState
            });
          };

          // Ìä∏ÎûôÏù¥ Ïù¥ÎØ∏ unmutedÎ©¥ Ï¶âÏãú, ÏïÑÎãàÎ©¥ Ï≤´ unmute Îïå Ïã§Ìñâ
          if (track.muted) {
            try { track.addEventListener?.('unmute', () => { void attachNow(); }, { once: true }); } catch { }
          } else {
            void attachNow();
          }

          return true;
        };

        const okV = await consumeKind('video');
        const okA = await consumeKind('audio');

        if (!okV && !okA) {
          setIsStreamAvailable(false);
          setStreamStatus('waiting');
          console.warn('[MS] producer ÏóÜÏùå ‚Üí new-producer ÎåÄÍ∏∞');
          socket.once('new-producer', async () => {
            const vv = await consumeKind('video');
            const aa = await consumeKind('audio');
            if (vv || aa) {
              setIsStreamAvailable(true);
              setStreamStatus('streaming');
              tryPlay(remoteVideoRef.current);
            }
          });
        } else {
          setIsStreamAvailable(true);
          setStreamStatus('streaming');
          tryPlay(remoteVideoRef.current);
        }
      } catch (error) {
        console.error('Mediasoup ÏÑ§Ï†ï Ïã§Ìå®:', error);
      }
    };

    socket.on('connect', setupMediasoup);

    socket.on('producer-closed', async () => {
      setStreamStatus('ended');
      setIsStreamAvailable(false);
      const v = remoteVideoRef.current;
      if (v?.srcObject) {
        v.srcObject.getTracks().forEach((t) => t.stop());
        v.srcObject = null;
      }
      msRef.current = null;
      setSubtitle(null);

      // üîπ Î∞©ÏÜ° Ï¢ÖÎ£å Ïãú ÏÑúÎ≤ÑÏóêÏÑú ÎÖπÌôî Í≤ΩÎ°úÍ∞Ä ÏÉùÍ≤ºÎäîÏßÄ Ïû¨Ï°∞Ìöå ÌõÑ VOD Ï†ÑÌôò ÏãúÎèÑ
      try {
        const streamResp = await getStream(liveId);
        const s = streamResp?.data?.data || streamResp?.data || {};
        const record = s?.record || s?.srRecord;
        if (record) {
          setVideoToVod(record);
        }
      } catch (e) {
        console.warn('Ï¢ÖÎ£å ÌõÑ VOD Ï†ÑÌôò Ïû¨Ï°∞Ìöå Ïã§Ìå®:', e);
      }
    });

    return () => {
      console.log('[Live] cleanup: disconnect');
      try { socket.disconnect(); } catch { }
      try { recvTransportRef.current?.close(); } catch { }
      const v = remoteVideoRef.current;
      if (v?.srcObject) {
        v.srcObject.getTracks().forEach((t) => t.stop());
        v.srcObject = null;
      }
      msRef.current = null;
      if (subtitleTimerRef.current) {
        clearTimeout(subtitleTimerRef.current);
        subtitleTimerRef.current = null;
      }
    };
  }, [liveId, streamStatus]);

  // ===== Mute ÌÉÄÏù¥Î®∏ =====
  useEffect(() => {
    if (!isMuted || muteSecondsLeft <= 0) {
      if (isMuted) setIsMuted(false);
      return;
    }
    const timerId = setInterval(() => setMuteSecondsLeft((p) => p - 1), 1000);
    return () => clearInterval(timerId);
  }, [isMuted, muteSecondsLeft]);

  // ===== ÏµúÍ∑º Î©îÏãúÏßÄ =====
  useEffect(() => {
    if (!artistId) return;
    const fetchRecent = async () => {
      try {
        const res = await fetch(`${CHAT_API_BASE_URL}/rooms/${artistId}/messages`);
        if (res.ok) {
          const history = await res.json();
          const formatted = history.map((m) => ({
            id: `${m.createdAt ?? Date.now()}-${Math.random()}`,
            senderId: m.senderId ?? 0,
            nickname: m.nickname ?? 'ÏùµÎ™Ö',
            text: m.content ?? '',
            type: m.contentType === 'SYSTEM' ? 'admin' : 'user',
            createdAt: m.createdAt,
          }));
          setChatList(formatted);
        }
      } catch (e) {
        console.error('[Chat] ÏµúÍ∑º Î©îÏãúÏßÄ Î°úÎî© Ïã§Ìå®:', e);
      }
    };
    fetchRecent();
  }, [artistId]);

  // ===== Ban Ï≤¥ÌÅ¨ =====
  useEffect(() => {
    console.log(`[Ban Check] Effect triggered. myUserId: ${myUserId}, artistId: ${artistId}`);
    // Î°úÍ∑∏Ïù∏Îêú ÏÇ¨Ïö©ÏûêÏù¥Í≥†, artistIdÍ∞Ä ÏûàÏùÑ ÎïåÎßå Ï≤¥ÌÅ¨
    if (myUserId && artistId) {
      const checkBanStatus = async () => {
        const url = `/chatapi/moderation/status?userId=${myUserId}&roomId=${artistId}`;
        console.log(`[Ban Check] Fetching ban status from: ${url}`);
        try {
          const response = await fetch(url);
          console.log(`[Ban Check] Response status: ${response.status}`);

          if (!response.ok) {
            console.error(`[Ban Check] API request failed with status ${response.status}`);
            return;
          }

          const data = await response.json();
          console.log('[Ban Check] Received data:', data);

          if (data.isBanned) {
            setIsBanned(true);
          } else {
            console.log('[Ban Check] User is not banned.');
          }
        } catch (error) {
          console.error('Ban status check failed with error:', error);
        }
      };

      checkBanStatus();
    } else {
      console.log('[Ban Check] Skipping check because myUserId or artistId is missing.');
    }
  }, [myUserId, artistId, navigate]);

  // ===== Ïú†Ìã∏ =====
  const formatTime = (isoString) => {
    if (!isoString) return '';
    const date = new Date(isoString);
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const ampm = hours >= 12 ? 'Ïò§ÌõÑ' : 'Ïò§Ï†Ñ';
    const formattedHours = hours % 12 || 12;
    return `${ampm} ${formattedHours}:${minutes.toString().padStart(2, '0')}`;
  };

  // ===== Ï±ÑÌåÖ ÏûÖÎ†• =====
  const handleChatInput = (e) => setChatInput(e.target.value);

  const handleChatKeyDown = (e) => {
    // IME(ÌïúÍ∏Ä) Ï°∞Ìï© Ï§ëÏù¥Î©¥ ÏóîÌÑ∞ Î¨¥Ïãú (ÌÅ¨Î°¨ ÎßàÏßÄÎßâ Í∏ÄÏûê Ï§ëÎ≥µ Î∞©ÏßÄ)
    if (e.key === 'Enter') {
      if (composingRef.current || e.nativeEvent.isComposing) return;
      handleChatSend();
    }
  };

  const handleChatSend = () => {
    const text = chatInput.trim();
    if (!text) return;

    if (!stompRef.current?.connected) {
      toast.error('Ï±ÑÌåÖ ÏÑúÎ≤ÑÏôÄ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
      return;
    }

    // ÏÑúÎ≤ÑÍ∞Ä ÌÜ†ÌÅ∞ÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÏãùÎ≥Ñ ‚Üí ÎÇ¥Ïö©Îßå Î≥¥ÎÉÑ
    const payload = { content: text };
    stompRef.current.publish({
      destination: APP_SEND(artistId),
      body: JSON.stringify(payload),
    });

    setChatInput('');
  };

  // ===== Í≥µÌÜµ Ïä§ÌÉÄÏùº(ÌîÑÎ°úÎ™®ÏÖò/ÏÉÅÌíà ÏÑπÏÖò ÌÜµÏùº) =====
  const styles = {
    section: {
      background: '#fff',
      borderRadius: 12,
      boxShadow: '0 4px 12px rgba(0,0,0,0.08)',
      padding: 20,
      marginTop: 30
    },
    title: {
      fontSize: 20,
      fontWeight: 800,
      color: '#222',
      margin: 0,
      paddingBottom: 12,
      borderBottom: '2px solid #eee',
      display: 'flex',
      alignItems: 'center',
      gap: 8,
    },
    grid: {
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fill, minmax(260px, 1fr))',
      gap: 18,
      paddingTop: 16
    },
    card: {
      border: '1px solid #eee',
      borderRadius: 12,
      background: 'linear-gradient(180deg, #fafafa 0%, #fff 100%)',
      boxShadow: '0 2px 8px rgba(0,0,0,0.06)',
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
      transition: 'transform 0.18s ease, box-shadow 0.18s ease',
    },
    cardHover: {
      transform: 'translateY(-4px)',
      boxShadow: '0 6px 16px rgba(0,0,0,0.10)',
    },
    imgWrap: {
      width: '100%',
      height: 180,
      background: '#f2f2f2',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    },
    img: {
      width: '100%',
      height: '100%',
      objectFit: 'cover'
    },
    body: {
      padding: 14,
      display: 'flex',
      flexDirection: 'column',
      gap: 8
    },
    name: {
      fontSize: 16,
      fontWeight: 700,
      color: '#222',
      lineHeight: 1.35
    },
    desc: {
      fontSize: 13,
      color: '#666',
      lineHeight: 1.5,
      height: 38,
      overflow: 'hidden',
      textOverflow: 'ellipsis'
    },
    metaRow: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginTop: 4
    },
    price: {
      fontSize: 16,
      fontWeight: 800,
      color: '#111'
    },
    badge: {
      fontSize: 12,
      padding: '3px 8px',
      borderRadius: 999,
      background: '#eef2ff',
      color: '#4f46e5',
      fontWeight: 700
    },
    actions: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: 8,
      padding: '0 14px 14px 14px'
    },
    btnOutline: {
      border: '1px solid #734ADE',
      background: 'transparent',
      color: '#734ADE',
      borderRadius: 10,
      fontWeight: 700,
      padding: '10px 12px',
      cursor: 'pointer'
    },
    btnFilled: {
      border: 'none',
      background: '#734ADE',
      color: '#fff',
      borderRadius: 10,
      fontWeight: 800,
      padding: '10px 12px',
      cursor: 'pointer'
    },
    // ÌîÑÎ°úÎ™®ÏÖò Ï†ÑÏö©(Ìè≠Ïù¥ ÎÑìÏùÄ Ïπ¥Îìú)
    promoGrid: {
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fit, minmax(320px, 1fr))',
      gap: 18,
      paddingTop: 16
    },
    promoImgWrap: {
      width: '100%',
      height: 220,
      background: '#f2f2ff'
    }
  };

  // ===== ÎîîÏûêÏù∏ Í∑∏ÎåÄÎ°ú Î†åÎçî =====
  if (isBanned) {
    return (
      <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100vh', backgroundColor: '#f8f9fa' }}>
        <h2 style={{ fontSize: '2rem', marginBottom: '1rem' }}>üö´ Ï†ëÍ∑ºÏù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§ üö´</h2>
        <p style={{ fontSize: '1.2rem', color: '#6c757d', marginBottom: '2rem' }}>Ïù¥ ÎùºÏù¥Î∏åÏóê ÎåÄÌïú Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.</p>
        <button
          onClick={() => navigate('/main')}
          style={{
            padding: '10px 20px',
            fontSize: '1rem',
            color: '#fff',
            backgroundColor: '#007bff',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer'
          }}
        >
          Î©îÏù∏ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞
        </button>
      </div>
    );
  }

  return (
    <div className="live-page-container">
      <div className="live-page-header">
        <h2 className="live-page-artist">
          {streamInfo?.artistName || 'ÏïÑÌã∞Ïä§Ìä∏'} <span style={{ color: '#7c4dff' }}>LIVE</span>
        </h2>
        <p className="live-page-desc">{streamInfo?.title || 'Î∞©ÏÜ° Ï†ïÎ≥¥ Î°úÎî© Ï§ë...'}</p>
      </div>

      <div className="live-page-stream-section">
        <div className="live-page-video-wrapper" style={{ position: 'relative' }}>
          <div className="viewer-count-badge">üëÄ {viewerCount}Î™Ö Ï†ëÏÜç Ï§ë</div>
          <video
            ref={remoteVideoRef}
            autoPlay={streamStatus !== 'vod'}
            muted={streamStatus !== 'vod'}
            controls={streamStatus === 'vod'}
            playsInline
            className="live-page-video"
            onResize={(e) => console.log('[Video] resize', e.currentTarget.videoWidth, e.currentTarget.videoHeight)}
            onLoadedMetadata={(e) => {
              console.log('[Video] loadedmetadata, readyState=', e.currentTarget.readyState);
              e.currentTarget.play?.().catch(() => { });
            }}
            onLoadedData={(e) => {
              console.log('[Video] loadeddata');
              e.currentTarget.play?.().catch(() => { });
            }}
            onCanPlay={(e) => {
              console.log('[Video] canplay');
              e.currentTarget.play?.().catch(() => { });
            }}
            onClick={(e) => {
              // ÎùºÏù¥Î∏å ÏûêÎèôÏû¨ÏÉù Ïã§Ìå® Ïãú ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÅ¥Î¶≠ÌïòÎ©¥ Ïû¨ÏÉù
              const v = e.currentTarget;
              if (streamStatus !== 'vod') {
                v.muted = true;
              }
              v.play?.().catch(err => console.error('ÏÇ¨Ïö©Ïûê ÌÅ¥Î¶≠ Ïû¨ÏÉù Ïã§Ìå®:', err));
            }}
            style={{
              cursor: 'pointer',
              width: '100%',
              minHeight: 320,
              background: '#000',
              objectFit: 'cover',
              borderRadius: 8
            }}
          />

          {!isStreamAvailable && streamStatus === 'waiting' && (
            <p className="live-page-waiting">Î∞©ÏÜ° ÏãúÏûëÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë...</p>
          )}
          {!isStreamAvailable && streamStatus === 'ended' && (
            <p className="live-page-waiting">Î∞©ÏÜ°Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.</p>
          )}
          {streamStatus === 'streaming' && (
            <>
              <SubtitleDisplay subtitle={subtitle} selectedLang={selectedLang} />
              <div className="subtitle-select-wrapper">
                <select value={selectedLang} onChange={(e) => setSelectedLang(e.target.value)}>
                  <option value="none">ÏûêÎßâ ÏóÜÏùå</option>
                  <option value="ko">ÌïúÍµ≠Ïñ¥</option>
                  <option value="en">English</option>
                  <option value="fr">Fran√ßais</option>
                </select>
              </div>
            </>
          )}
        </div>

        <div className="live-page-chat-section" style={{ height: '100%' }}>
          <div className="live-page-chat-title">Ïã§ÏãúÍ∞Ñ Ï±ÑÌåÖ</div>
          <div className="live-page-chat-messages" ref={chatMessagesRef}>
            {chatList.map((msg) => {
              const isMine = myUserId && msg.senderId === myUserId && msg.type !== 'admin';

              // ÏÑúÎ≤Ñ ÎãâÎÑ§ÏûÑ Ïö∞ÏÑ† ÏÇ¨Ïö©
              const name =
                msg.type === 'admin'
                  ? 'ÏãúÏä§ÌÖú'
                  : isMine
                    ? (msg.nickname || sender)
                    : (msg.nickname || 'ÏùµÎ™Ö');

              const time = formatTime(msg.createdAt);

              return (
                <div
                  key={msg.id}
                  style={{
                    display: 'flex',
                    justifyContent: isMine ? 'flex-end' : 'flex-start',
                    margin: '5px 0'
                  }}
                >
                  {isMine && (
                    <span
                      style={{
                        alignSelf: 'flex-end',
                        fontSize: '0.75rem',
                        color: '#999',
                        marginRight: 8
                      }}
                    >
                      {time}
                    </span>
                  )}

                  <div
                    className={msg.type === 'admin' ? 'live-page-chat-admin' : 'live-page-chat-user'}
                    style={{ maxWidth: '70%' }}
                  >
                    <span
                      className="live-page-chat-sender"
                      style={{ color: msg.type === 'admin' ? '#3b4fff' : '#222', fontWeight: 600 }}
                    >
                      {name}:
                    </span>{' '}
                    <span className="live-page-chat-text">{msg.text}</span>
                  </div>

                  {!isMine && (
                    <span
                      style={{
                        alignSelf: 'flex-end',
                        fontSize: '0.75rem',
                        color: '#999',
                        marginLeft: 8
                      }}
                    >
                      {time}
                    </span>
                  )}
                </div>
              );
            })}
          </div>

          <div className="live-page-chat-input-wrap">
            <input
              type="text"
              className="live-page-chat-input"
              placeholder={isMuted ? `${muteSecondsLeft}Ï¥à ÎèôÏïà Ï±ÑÌåÖÏù¥ Í∏àÏßÄÎêòÏóàÏäµÎãàÎã§.` : "Î©îÏãúÏßÄ Î≥¥ÎÇ¥Í∏∞.."}
              value={chatInput}
              onChange={handleChatInput}
              onCompositionStart={() => { composingRef.current = true; }} // IME ÏãúÏûë
              onCompositionEnd={() => { composingRef.current = false; }}  // IME Ï¢ÖÎ£å
              onKeyDown={handleChatKeyDown}
              disabled={isMuted}
            />
          </div>
        </div>
      </div>

      {/* ===== ÌîÑÎ°úÎ™®ÏÖò & ÏÉÅÌíà: ÌÜµÏùºÎêú ÎîîÏûêÏù∏ ===== */}
      <div style={styles.section}>
        <h3 style={styles.title}>üéÅ ÌîÑÎ°úÎ™®ÏÖò ÏÉÅÌíà</h3>
        <div style={styles.promoGrid}>
          {promotion ? (
            <div
              style={styles.card}
              onMouseEnter={(e) => {
                e.currentTarget.style.transform = styles.cardHover.transform;
                e.currentTarget.style.boxShadow = styles.cardHover.boxShadow;
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.transform = '';
                e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.06)';
              }}
            >
              <div style={{ ...styles.imgWrap, ...styles.promoImgWrap }}>
                <img
                  src={promotion.img ? `${import.meta.env.VITE_API_URL}${promotion.img}` : '/assets/img/placeholder/240.png'}
                  alt={promotion.name}
                  style={styles.img}
                />
              </div>
              <div style={styles.body}>
                <div style={styles.name}>{promotion.name}</div>
                <div style={styles.desc}>{promotion.description || 'Îì±Î°ùÎêú ÏÑ§Î™ÖÏù¥ ÏóÜÏäµÎãàÎã§.'}</div>
                <div style={styles.metaRow}>
                  <span style={styles.badge}>
                    Ïû¨Í≥† {promotion.stockQty ?? 0}Í∞ú
                  </span>
                  {promotion.fanOnly && <span style={styles.badge}>Ìå¨ÌÅ¥ÎüΩ Ï†ÑÏö©</span>}
                </div>
                {promotion.coupon && (
                  <div style={{ ...styles.metaRow, marginTop: 6 }}>
                    <span style={{ fontSize: 13, color: '#444' }}>Ïø†Ìè∞ ÏΩîÎìú</span>
                    <strong style={{ fontSize: 14, color: '#111' }}>{promotion.coupon}</strong>
                  </div>
                )}
              </div>
              <div style={styles.actions}>
                <button style={styles.btnOutline}>ÏûêÏÑ∏Ìûà Î≥¥Í∏∞</button>
                <button style={styles.btnFilled}>Íµ¨Îß§ÌïòÍ∏∞</button>
              </div>
            </div>
          ) : (
            <div style={{ padding: 30, textAlign: 'center', color: '#777' }}>
              Îì±Î°ùÎêú ÌîÑÎ°úÎ™®ÏÖòÏù¥ ÏóÜÏäµÎãàÎã§.
            </div>
          )}
        </div>
      </div>

      <div style={styles.section}>
        <h3 style={styles.title}>üõí ÎùºÏù¥Î∏å ÏÉÅÌíà Î™©Î°ù</h3>
        <div className="live-page-product-list" style={styles.grid}>
          {productDetails.length > 0 ? (
            productDetails.map((p) => (
              <div
                key={p.id}
                className="live-page-product-card live-page-product-card-wide"
                style={styles.card}
                onMouseEnter={(e) => {
                  e.currentTarget.style.transform = styles.cardHover.transform;
                  e.currentTarget.style.boxShadow = styles.cardHover.boxShadow;
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.transform = '';
                  e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.06)';
                }}
              >
                <div style={styles.imgWrap}>
                  <img
                    src={p.img ? `${import.meta.env.VITE_API_URL}${p.img}` : '/assets/img/placeholder/240.png'}
                    alt={p.name}
                    className="live-page-product-img"
                    style={styles.img}
                  />
                </div>

                <div className="live-page-product-info" style={styles.body}>
                  <div className="live-page-product-name" style={styles.name}>{p.name}</div>
                  {p.description && (
                    <div style={styles.desc}>{p.description}</div>
                  )}
                  <div style={styles.metaRow}>
                    <span style={styles.badge}>Ïû¨Í≥† {p.stockQty ?? 0}Í∞ú</span>
                    {p.fanOnly && <span style={styles.badge}>Ìå¨ÌÅ¥ÎüΩ Ï†ÑÏö©</span>}
                  </div>
                </div>

                <div style={{ ...styles.metaRow, padding: '0 14px 10px 14px' }}>
                  <span className="live-page-product-price" style={styles.price}>
                    ‚Ç©{Number(p.price || 0).toLocaleString()}
                  </span>
                </div>

                <div className="live-page-product-buttons-col" style={styles.actions}>
                  <button className="live-page-btn-cart live-page-btn-outline" style={styles.btnOutline}>Ïû•Î∞îÍµ¨Îãà</button>
                  <button className="live-page-btn-buy live-page-btn-filled" style={styles.btnFilled}>Ï£ºÎ¨∏ÌïòÍ∏∞</button>
                </div>
              </div>
            ))
          ) : (
            <div className="live-page-product-empty" style={{ padding: 30, textAlign: 'center', color: '#777' }}>
              Îì±Î°ùÎêú ÏÉÅÌíàÏù¥ ÏóÜÏäµÎãàÎã§.
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
